COURSE: OPERATING SYSTEMS 
PA1 Answers:

LINUXSCHED:
Advantages:
1) Higher priority processes are preferred to execute first and if they run for a longer time, they cause starvation. Meanwhile, other processes with lower priority just have to wait for ever before given a chance to execute. A Linux-like scheduler takes both CPU time and priority in terms of a new factor called goodness to schedule any process. Hence, starvation is overcome.
2) A process that has hasn't completed its allocated CPU time, it will be given more time and higher preference in the next epoch.

Disadvantages:
1) If many processes are in ready state, first process with maximum goodness have to wait for long time till all processes finish their quantum.
2) A process with very high priority has to wait for completion of that epoch in which it was put in ready queue.
3)Even if it solves the purpose of starvation, a process with extremely high priority and very long CPU time will always run first.

RANDOMSCHED:
Advantages: 
1)It can be used efficiently as it does allow higher priority process to run before lower priority processes.
2)Fairness is one of the properties provided by this scheduler as every process is randomly selected. 

Disadvantage:
1)Higher priority will not necessarily run first and before the processes with lower priority. It all depends upon the random number generated by the rand() function.
2) Starvation is still possible if the randomly chosen process has a huge allocated CPU time.
3)More time required for context switching when compared to original xinu scheduler.
4)High degree of unpredictability and randomness.

Original Round-robin scheduling of Xinu: 
Advantages:
1)The time consumed in context switching is less as it just selects the max priority process. 
2)Easy algorithm and simple to implement.

Disadvantages:
1)Process starvation which means that a process with higher priority and a huge CPU time allocated will hog all the resources leading to a halt for other processes.
2)Non-preemptive type of scheduler.
3)Unequal task lengths. Consider processes p1 and p2 with same priority but p1 having a huge allocated CPU time compared to p2. Hence, p1 will keep on executing.     

Q2. Consider the priorities 20, 30 and 50 for P1, P2 and P3 respectively.
Hence, generalizing will obtain from 20/(20+30+50) which is 1/5=20% which is supposed to be the CPU time allocation. Finally, if there are n number of process, then their CPU time allocated will be (Pth priority /sum of  ‘n’ priorities).  
Another example could be processes with priorities 40, 60 and 100 respectively.

Q3.
Random scheduler:
The null process will be scheduled only when there are no other processes in the ready queue. And only the null process is there to be scheduled until another process joins the ready queue.

Linux-scheduler:
The null process is scheduled in the beginning when the ready queue is empty and then it calls the main function which creates and puts processes A, B and C in the ready queue. Other times, null process will be scheduled when some process are in wait state and their respective quantum is not zero. For that duration until the process goes back to ready queue and finally to running state. So, basically null process is run when it is the only process in the ready queue.


